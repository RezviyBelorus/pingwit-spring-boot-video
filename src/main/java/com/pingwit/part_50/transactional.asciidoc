= Аннотация `@Transactional` в Spring

Аннотация **`@Transactional`** в Spring используется для управления транзакциями в приложениях. Она позволяет разработчикам обозначить методы или классы, которые должны выполняться в рамках транзакции, предоставляя гибкое и мощное управление транзакциями без необходимости прописывать их вручную. Spring берет на себя ответственность за открытие, коммит и откат транзакций, что упрощает работу с базой данных и делает код более чистым.

== Основные особенности аннотации `@Transactional`

1. *Автоматическое управление транзакцией*
Spring автоматически открывает транзакцию при вызове метода, помеченного `@Transactional`.
После завершения метода Spring выполняет **commit** транзакции, если метод завершился успешно, или **rollback** транзакции, если было выброшено исключение (по умолчанию `RuntimeException` или `Error`).

2. *Гибкость на уровне методов и классов*
`@Transactional` можно применить к классу или методу.
При применении на уровне класса аннотация действует для всех методов, и каждый метод будет выполняться в транзакции. При применении на уровне метода аннотация действует только для этого метода.

3. *Настраиваемое поведение коммита и отката*
Spring позволяет указать, для каких исключений транзакция должна быть откатана (например, `rollbackFor`).
Можно настроить, чтобы транзакция откатывалась для проверяемых (checked) исключений, если это необходимо.

4. *Поддержка различных уровней изоляции и распространения транзакций*
`@Transactional` позволяет указать **уровень изоляции** (например, `READ_COMMITTED`, `REPEATABLE_READ`, `SERIALIZABLE`), чтобы управлять параллелизмом доступа к данным.
Поддерживаются также различные **пропагации транзакций** (например, `REQUIRED`, `REQUIRES_NEW`, `SUPPORTS`), которые управляют тем, как транзакции взаимодействуют с текущими транзакциями.

== Основные атрибуты аннотации `@Transactional`

1. **`propagation`**: Определяет, как текущий метод транзакции должен взаимодействовать с уже существующей транзакцией (если она есть).
* **`REQUIRED`** (по умолчанию): Использует существующую транзакцию, если она есть, иначе создаёт новую.
* **`REQUIRES_NEW`**: Всегда создаёт новую транзакцию, даже если текущая уже существует.
* **`SUPPORTS`**: Использует существующую транзакцию, если она есть, но если её нет, работает без транзакции.
* **`MANDATORY`**: Требует наличия активной транзакции, иначе выбрасывает исключение.
* **`NOT_SUPPORTED`**: Выполняет метод вне транзакции, даже если она уже существует.
* **`NEVER`**: Метод никогда не должен запускаться в транзакции, выбрасывает исключение, если транзакция активна.

2. **`isolation`**: Определяет уровень изоляции транзакции для предотвращения конфликтов данных при параллельных операциях.
* **`DEFAULT`**: Использует уровень изоляции по умолчанию, установленный в базе данных.
* **`READ_UNCOMMITTED`**: Разрешает чтение незавершённых данных, что может привести к некорректным данным.
* **`READ_COMMITTED`**: Гарантирует, что все прочитанные данные были закоммичены.
* **`REPEATABLE_READ`**: Обеспечивает неизменяемость прочитанных данных в рамках одной транзакции.
* **`SERIALIZABLE`**: Самый высокий уровень изоляции, предотвращает все типы конфликтов, но снижает производительность.

3. **`rollbackFor` и `noRollbackFor`**: Управляют поведением отката.
* **`rollbackFor`**: Определяет, для каких исключений транзакция должна быть откатана. По умолчанию это `RuntimeException` и `Error`.
* **`noRollbackFor`**: Определяет, для каких исключений откат не должен выполняться, даже если они были выброшены.

4. **`readOnly`**: Если установлено в `true`, то транзакция считается только для чтения и оптимизируется Hibernate и база данных. Это может быть полезно для улучшения производительности.

5. **`timeout`**: Устанавливает тайм-аут транзакции (в секундах). Если транзакция не завершится за это время, то она будет автоматически откатана.

== Пример использования `@Transactional`

=== 1. Пример использования на уровне класса

[source,java]
----
@Service
@Transactional  // Все методы этого класса будут выполняться в транзакции
public class UserService {

    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public User createUser(User user) {
        return userRepository.save(user);
    }

    public User findUser(Long id) {
        return userRepository.findById(id).orElse(null);
    }

    public void deleteUser(Long id) {
        userRepository.deleteById(id);
    }
}
----

=== 2. Пример использования на уровне метода

[source,java]
----
@Service
public class UserService {

    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Transactional  // Только этот метод будет в транзакции
    public User createUser(User user) {
        return userRepository.save(user);
    }

    // Метод без аннотации @Transactional будет выполняться вне транзакции
    public User findUser(Long id) {
        return userRepository.findById(id).orElse(null);
    }

    @Transactional
    public void deleteUser(Long id) {
        userRepository.deleteById(id);
    }
}
----

== Как работает `@Transactional` в Spring

1. *Прокси-обёртка*: Spring использует прокси для оборачивания методов, аннотированных `@Transactional`. Когда такой метод вызывается, прокси автоматически открывает транзакцию.
2. *Коммит или откат*: После выполнения метода Spring проверяет, было ли выброшено исключение. Если метод завершился успешно, транзакция коммитится. Если выбрасывается исключение (по умолчанию `RuntimeException`), транзакция откатывается.
3. *Не распространяется на внутренние вызовы методов*: Если `@Transactional` метод вызывает другой метод в том же классе, `@Transactional` не сработает, так как Spring проксирует только внешние вызовы.

== Заключение

Аннотация `@Transactional` в Spring значительно упрощает управление транзакциями, позволяя избежать ручного открытия, коммита и отката транзакций. Она позволяет настроить гибкие стратегии управления транзакциями и обеспечивать согласованность данных, что делает её незаменимой при работе с базой данных в Spring-приложениях.
